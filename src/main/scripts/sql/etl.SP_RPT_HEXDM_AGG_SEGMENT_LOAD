---------------------------------------------------------------------------------------------------------------------------------
--   Date			Author			Description
--   ---------- 	----------		---------------------------------------------------------------------------------------------
--   2013-12-17		nsucheendran	This stored procedure loads data for the HEX data mart for Live and Completed Experiments
--------------------------------------------------------------------------------------------------------------------------------
--#SET TERMINATOR @

set schema edw
@
call dbadm.sp_drop_procedure('ETL','SP_RPT_HEXDM_AGG_SEGMENT_LOAD')
@
call sysproc.set_routine_opts('REOPT ALWAYS')
@

CREATE PROCEDURE ETL.SP_RPT_HEXDM_AGG_SEGMENT_LOAD ()
   DYNAMIC RESULT SETS 1
   LANGUAGE SQL
   BEGIN
      ---------------------------------------------------------------------
      -- Declarations
      ---------------------------------------------------------------------
      DECLARE stmt            VARCHAR (2048) DEFAULT '';
      DECLARE MyMesg          VARCHAR (256);
      DECLARE mysqlstate      CHAR (5) DEFAULT '00000';
      DECLARE spname          VARCHAR (128) DEFAULT 'SP_RPT_HEXDM_AGG_SEGMENT_LOAD';
      DECLARE v_entity        VARCHAR (50) DEFAULT 'SP_RPT_HEXDM_AGG_SEGMENT_LOAD';
      DECLARE nextid          INTEGER  DEFAULT 0;
      DECLARE sqlstate        CHAR (5) DEFAULT '00000';
      DECLARE runid           INTEGER  DEFAULT 0;
      DECLARE rcount          INTEGER;
      DECLARE load_tag        INTEGER;
      DECLARE CurrentRunDTM   TIMESTAMP;
      DECLARE S1              VARCHAR (2048);
      DECLARE S2              VARCHAR (2048);
      DECLARE S3              VARCHAR (2048);
      DECLARE v_parameters    VARCHAR (2000);
      DECLARE v_count         INTEGER;

      DECLARE EXIT HANDLER FOR SQLEXCEPTION BEGIN
                                               DECLARE v_message    VARCHAR (1024);
                                               DECLARE v_nextid     INTEGER;
                                               DECLARE v_sqlstate   CHAR (5);

                                               GET DIAGNOSTICS EXCEPTION 1
                                               v_message = MESSAGE_TEXT;
                                               SET v_sqlstate = SQLSTATE;
                                               ROLLBACK WORK;

                                               SELECT coalesce (
                                                         max (error_id) + 1,
                                                         0)
                                                 INTO v_nextid
                                                 FROM etl_sproc_error
                                                 WITH RR USE AND KEEP EXCLUSIVE LOCKS;

                                               INSERT INTO etl_sproc_error
                                               VALUES (v_nextid,
                                                       CURRENT TIMESTAMP,
                                                       v_entity,
                                                       Stmt,
                                                       v_message);

                                               COMMIT;

                                               CALL etl.sp_trace (
                                                       entity             => v_entity,
                                                       step_info          => Stmt
                                                                            || ' Failure',
                                                       parameter_info     => v_parameters,
                                                       r_count            => rcount,
                                                       etl_load_tag       => load_tag,
                                                       error_state_code   => v_sqlstate,
                                                       error_mesg_info    => v_message);

                                               SET v_message =
                                                      'Procedure failed. Check ETL_SPROC_ERROR. ERROR_ID='
                                                      || char (v_nextid);
                                               SIGNAL SQLSTATE v_sqlstate SET MESSAGE_TEXT = v_message;
                                               RETURN 8;
                                            END;

      ----------------------------------------------------------------------------
      -- Inserting sproc details into etl.hww_trace
      ---------------------------------------------------------------------------
      CALL etl.sp_trace (entity         => v_entity,
                         step_info      => 'Procedure start',
                         r_count        => NULL,
                         etl_load_tag   => load_tag);

---------------------------------------------------------------------------------------
-- Create session table for the Completed Experiments from the Incremental Data Set
---------------------------------------------------------------------------------------

   DECLARE GLOBAL TEMPORARY TABLE session.RPT_HEXDM_AGG_SEGMENT_COMP(
    SEGMENT_NUMBER          SMALLINT,
    SEGMENT_NAME            VARCHAR(100),
    LOCAL_DATE          VARCHAR(100),
	NEW_VISITOR_IND     VARCHAR(100),
	PAGE_ASSIGNED_ENTRY_PAGE_NAME   VARCHAR(300),
	SITE_SECTN_NAME     VARCHAR(100),
	USER_CNTEXT_NAME          VARCHAR(100),
	BROWSER_HEIGHT      VARCHAR(100),
	BROWSER_WIDTH       VARCHAR(100),
	MOBILE_IND          VARCHAR(100),
	PLATFORM_TYPE       VARCHAR(100),
	DAYS_UNTIL_STAY     VARCHAR(100),
	LENGTH_OF_STAY      VARCHAR(100) ,
	NUMBER_OF_ROOMS     VARCHAR(100),
	NUMBER_OF_ADULTS_CHILDREN   VARCHAR(100),
	CHILDREN_IN_SEARCH_FLAG   VARCHAR(100),
	ENTRY_PAGE_NAME     VARCHAR(100),
	EXPERIMENT_NAME     VARCHAR(100),
	VARIANT_NAME        VARCHAR(100),
	REPORT_START_DATE         VARCHAR(100),
	REPORT_END_DATE     VARCHAR(100),
	STATUS        VARCHAR(100),
	REPORT_TRANSACTION_END_DATE     VARCHAR(100),
	TEST_MANAGER        VARCHAR(100),
	PRODUCT_MANAGER     VARCHAR(100),
	POD           VARCHAR(100),
	EXPERIMENT_TEST_ID        VARCHAR(100),
	OPERATING_SYSTEM_NAME     VARCHAR(100),
	BRWSR_NAME          VARCHAR(100),
	BRWSR_TYP_NAME      VARCHAR(100),
	PROPERTY_TYP_NAME         VARCHAR(100),
	PROPERTY_PARNT_CHAIN_NAME       VARCHAR(100),
	PROPERTY_BRAND_NAME       VARCHAR(100),
	PROPERTY_SUPER_REGN_NAME        VARCHAR(100),
	PROPERTY_REGN_ID          INT,
	PROPERTY_REGN_NAME        VARCHAR(100),
	PROPERTY_MKT_ID     INT,
	PROPERTY_MKT_NAME         VARCHAR(100),
	PROPERTY_SUB_MKT_ID       INT,
	PROPERTY_SUB_MKT_NAME     VARCHAR(100),
	PROPERTY_CNTRY_NAME       VARCHAR(100),
	PROPERTY_STATE_PROVNC_NAME      VARCHAR(100),
	PROPERTY_CITY_NAME        VARCHAR(100),
	EXPE_HALF_STAR_RTG        VARCHAR(100),
	PROPERTY_PARNT_CHAIN_ACCT_TYP_NAME      VARCHAR(100),
	PROPERTY_PAYMNT_CHOICE_ENABL_IND        VARCHAR(100),
	PROPERTY_CNTRCT_MODEL_NAME      VARCHAR(100),
	POSA_SUPER_REGION         VARCHAR(100),
	POSA_REGION         VARCHAR(100),
	POSA_COUNTRY        VARCHAR(100),
	MKTG_CHNNL_NAME     VARCHAR(100),
	MKTG_SUB_CHNNL_NAME       VARCHAR(100),
	MKTG_CHNNL_NAME_DIRECT    VARCHAR(100),
	MKTG_SUB_CHNNL_NAME_DIRECT      VARCHAR(100),
	HCOM_SRCH_DEST_TYP_NAME   VARCHAR(100),
	HCOM_SRCH_DEST_NAME       VARCHAR(100),
	HCOM_SRCH_DEST_CNTRY_NAME       VARCHAR(100),
	HCOM_SRCH_DEST_ID         VARCHAR(100),
	PSG_MKT_NAME        VARCHAR(100),
	PSG_MKT_REGN_NAME         VARCHAR(100),
	PSG_MKT_SUPER_REGN_NAME   VARCHAR(100),
	DOM_INTL_FLAG       VARCHAR(100),
	NUM_UNIQUE_VIEWERS        BIGINT,
	NUM_UNIQUE_PURCHASERS     BIGINT,
	NUM_UNIQUE_CANCELLERS     BIGINT,
	NUM_ACTIVE_PURCHASERS     BIGINT,
	NUM_INACTIVE_PURCHASERS    BIGINT,
	TOTAL_CANCELLATIONS       BIGINT,
	NET_ORDERS          BIGINT,
	NET_BKG_GBV         DOUBLE,
	NET_BKG_ROOM_NIGHTS       BIGINT,
	NET_OMNITURE_GBV          DOUBLE,
	NET_OMNITURE_ROOM_NIGHTS        BIGINT,
	NET_GROSS_PROFIT          DOUBLE,
	NUM_REPEAT_PURCHASERS     BIGINT,
	EXPERIMENT_CODE           VARCHAR(100),
	VARIANT_CODE              VARCHAR(100),
	VERSION_NUMBER            SMALLINT
    )
     IN ts_usertemp00
   WITH REPLACE
   ON COMMIT PRESERVE ROWS
   NOT LOGGED;

      INSERT INTO session.RPT_HEXDM_AGG_SEGMENT_COMP
         SELECT *
           FROM DM.RPT_HEXDM_AGG_SEGMENT
          WHERE STATUS = 'Completed'
           WITH UR;

      GET DIAGNOSTICS rcount = ROW_COUNT;

      CALL etl.sp_trace (
              entity           => v_entity,
              step_info        => 'Insert of completed experiments into Session table Successful ',
              r_count          => rcount);

--------------------------------------------------------------------------------------------
-- Create session table for the Completed Experiments  to be deleted  from Existing data set
--------------------------------------------------------------------------------------------

  DECLARE GLOBAL TEMPORARY TABLE session.del_experiment_key (
    RPT_HEX_AGG_KEY BIGINT
  )
  IN TS_USERTEMP
  WITH REPLACE
  ON COMMIT PRESERVE ROWS
  NOT LOGGED
;

      INSERT INTO session.del_experiment_key
         SELECT RPT_HEX_AGG_KEY
           FROM DM.RPT_HEXDM_AGG_SEGMENT_COMP
          WHERE (EXPERIMENT_CODE, VARIANT_CODE, VERSION_NUMBER) IN
                   (SELECT DISTINCT
                           EXPERIMENT_CODE, VARIANT_CODE, VERSION_NUMBER
                      FROM session.RPT_HEXDM_AGG_SEGMENT_COMP);

      GET DIAGNOSTICS rcount = ROW_COUNT;

      CALL etl.sp_trace (
              entity           => v_entity,
              step_info        => 'Insert of the keys to be deleted successful',
              r_count          => rcount);


      ----------------------------------------------------------------------------------------------------
      -- Delete Completed Experiments from the Existing data set that are also in the current Incremental
      ----------------------------------------------------------------------------------------------------


      DELETE FROM DM.RPT_HEXDM_AGG_SEGMENT_COMP TGT
       WHERE EXISTS
                (SELECT 1
                   FROM session.del_experiment_key D
                  WHERE D.RPT_HEX_AGG_KEY = TGT.RPT_HEX_AGG_KEY);

      GET DIAGNOSTICS rcount = ROW_COUNT;

      CALL etl.sp_trace (
              entity           => v_entity,
              step_info        => 'Delete Already existing Completed Experiments from DM.RPT_HEXDM_AGG_SEGMENT_COMP',
              r_count          => rcount
              );

      ----------------------------------------------------------------------------------------------------
      -- Data Load to the final DM table for completed experiments
      ----------------------------------------------------------------------------------------------------

      INSERT INTO DM.RPT_HEXDM_AGG_SEGMENT_COMP (
                     SEGMENT_NUMBER,
                     SEGMENT_NAME,
                     LOCAL_DATE,
                     NEW_VISITOR_IND,
                     PAGE_ASSIGNED_ENTRY_PAGE_NAME,
                     SITE_SECTN_NAME,
                     USER_CNTEXT_NAME,
                     BROWSER_HEIGHT,
                     BROWSER_WIDTH,
                     MOBILE_IND,
                     PLATFORM_TYPE,
                     DAYS_UNTIL_STAY,
                     LENGTH_OF_STAY,
                     NUMBER_OF_ROOMS,
                     NUMBER_OF_ADULTS_CHILDREN,
                     CHILDREN_IN_SEARCH_FLAG,
                     ENTRY_PAGE_NAME,
                     EXPERIMENT_NAME,
                     VARIANT_NAME,
                     REPORT_START_DATE,
                     REPORT_END_DATE,
                     STATUS,
                     REPORT_TRANSACTION_END_DATE,
                     TEST_MANAGER,
                     PRODUCT_MANAGER,
                     POD,
                     EXPERIMENT_TEST_ID,
                     OPERATING_SYSTEM_NAME,
                     BRWSR_NAME,
                     BRWSR_TYP_NAME,
                     PROPERTY_TYP_NAME,
                     PROPERTY_PARNT_CHAIN_NAME,
                     PROPERTY_BRAND_NAME,
                     PROPERTY_SUPER_REGN_NAME,
                     PROPERTY_REGN_ID,
                     PROPERTY_REGN_NAME,
                     PROPERTY_MKT_ID,
                     PROPERTY_MKT_NAME,
                     PROPERTY_SUB_MKT_ID,
                     PROPERTY_SUB_MKT_NAME,
                     PROPERTY_CNTRY_NAME,
                     PROPERTY_STATE_PROVNC_NAME,
                     PROPERTY_CITY_NAME,
                     EXPE_HALF_STAR_RTG,
                     PROPERTY_PARNT_CHAIN_ACCT_TYP_NAME,
                     PROPERTY_PAYMNT_CHOICE_ENABL_IND,
                     PROPERTY_CNTRCT_MODEL_NAME,
                     POSA_SUPER_REGION,
                     POSA_REGION,
                     POSA_COUNTRY,
                     MKTG_CHNNL_NAME,
                     MKTG_SUB_CHNNL_NAME,
                     MKTG_CHNNL_NAME_DIRECT,
                     MKTG_SUB_CHNNL_NAME_DIRECT,
                     HCOM_SRCH_DEST_TYP_NAME,
                     HCOM_SRCH_DEST_NAME,
                     HCOM_SRCH_DEST_CNTRY_NAME,
                     HCOM_SRCH_DEST_ID,
                     PSG_MKT_NAME,
                     PSG_MKT_REGN_NAME,
                     PSG_MKT_SUPER_REGN_NAME,
                     DOM_INTL_FLAG,
                     NUM_UNIQUE_VIEWERS,
                     NUM_UNIQUE_PURCHASERS,
                     NUM_UNIQUE_CANCELLERS,
                     NUM_ACTIVE_PURCHASERS,
                     NUM_INACTIVE_PURCHASERS,
                     TOTAL_CANCELLATIONS,
                     NET_ORDERS,
                     NET_BKG_GBV,
                     NET_BKG_ROOM_NIGHTS,
                     NET_OMNITURE_GBV,
                     NET_OMNITURE_ROOM_NIGHTS,
                     NET_GROSS_PROFIT,
                     NUM_REPEAT_PURCHASERS,
					 EXPERIMENT_CODE,
					 VARIANT_CODE,
					 VERSION_NUMBER)
         SELECT * FROM session.RPT_HEXDM_AGG_SEGMENT_COMP;

      GET DIAGNOSTICS rcount = ROW_COUNT;

      CALL etl.sp_trace (
              entity           => v_entity,
              step_info        => 'Insert Completed Experiments to DM.RPT_HEXDM_AGG_SEGMENT_COMP',
              r_count          => rcount
              );

      CALL sysproc.admin_cmd ('reorg table DM.RPT_HEXDM_AGG_SEGMENT_COMP');

      CALL etl.sp_trace (
              entity           => v_entity,
              step_info        => 'Reorg successful for DM.RPT_HEXDM_AGG_SEGMENT_COMP'
              );

      ----------------------------------------------------------------------------------------------------
      -- The section below does the following
      -- 1. Drop the alias for RPT_HEXDM_AGG_SEGMENT_LIVE
      -- 2. Check if the RPT_HEXDM_AGG_SEGMENT_LIVE exists. If yes, drop and rename RPT_HEXDM_AGG_SEGMENT
      --          to RPT_HEXDM_AGG_SEGMENT_LIVE
      -- 3. If not, Log the step and proceed
      -- 4. Create the aliases and runstats
      ----------------------------------------------------------------------------------------------------
      CALL etl.sp_trace (entity => v_entity, step_info => 'Dropping aliases');

      CALL dbadm.sp_drop_alias ('EDW', 'RPT_HEXDM_AGG_SEGMENT_LIVE');

      SET  SCHEMA DM;

      SELECT count (*)
        INTO v_count
        FROM syscat.tables
       WHERE tabschema = 'DM' AND tabname = 'RPT_HEXDM_AGG_SEGMENT_LIVE';

      IF v_count = 1
      THEN
         SET S1 = 'drop table RPT_HEXDM_AGG_SEGMENT_LIVE';
         EXECUTE IMMEDIATE S1;
         COMMIT;
         CALL etl.sp_trace (entity      => v_entity,
                            step_info   => 'Live Table Dropped');
      ELSE
         CALL etl.sp_trace (
                 entity      => v_entity,
                 step_info   => 'Live table does not exist, proceeding to next step');
      END IF;

      SET S2 = 'rename table RPT_HEXDM_AGG_SEGMENT TO RPT_HEXDM_AGG_SEGMENT_LIVE';
      EXECUTE IMMEDIATE S2;
      COMMIT;

      CALL etl.sp_trace (entity      => v_entity,
                         step_info   => 'Table Renamed from Segment to Live');

      CALL dbadm.sp_drop_index ('DM', 'IX2_RPT_HEXDM_AGG_SEGMENT_LIVE');
CREATE INDEX DM.IX2_RPT_HEXDM_AGG_SEGMENT_LIVE ON DM.RPT_HEXDM_AGG_SEGMENT_LIVE (STATUS) ALLOW REVERSE SCANS;

      CALL dbadm.sp_drop_index ('DM', 'IX4_RPT_HEXDM_AGG_SEGMENT_LIVE');
CREATE INDEX DM.IX4_RPT_HEXDM_AGG_SEGMENT_LIVE ON DM.RPT_HEXDM_AGG_SEGMENT_LIVE (EXPERIMENT_CODE, VERSION_NUMBER) ALLOW REVERSE SCANS;

      CALL dbadm.sp_drop_index ('DM', 'IX5_RPT_HEXDM_AGG_SEGMENT_LIVE');
CREATE INDEX DM.IX5_RPT_HEXDM_AGG_SEGMENT_LIVE ON DM.RPT_HEXDM_AGG_SEGMENT_LIVE (POSA_SUPER_REGION) ALLOW REVERSE SCANS;

      CALL dbadm.sp_drop_index ('DM', 'IX6_RPT_HEXDM_AGG_SEGMENT_LIVE');
CREATE INDEX DM.IX6_RPT_HEXDM_AGG_SEGMENT_LIVE ON DM.RPT_HEXDM_AGG_SEGMENT_LIVE (POSA_REGION) ALLOW REVERSE SCANS;

      CALL dbadm.sp_drop_index ('DM', 'IX7_RPT_HEXDM_AGG_SEGMENT_LIVE');
CREATE INDEX DM.IX7_RPT_HEXDM_AGG_SEGMENT_LIVE ON DM.RPT_HEXDM_AGG_SEGMENT_LIVE (POSA_COUNTRY) ALLOW REVERSE SCANS;

      CALL dbadm.sp_drop_index ('DM', 'IX8_RPT_HEXDM_AGG_SEGMENT_LIVE');
CREATE INDEX DM.IX8_RPT_HEXDM_AGG_SEGMENT_LIVE ON DM.RPT_HEXDM_AGG_SEGMENT_LIVE (REPORT_START_DATE) ALLOW REVERSE SCANS;

      SET S3 = 'CREATE ALIAS EDW.RPT_HEXDM_AGG_SEGMENT_LIVE FOR DM.RPT_HEXDM_AGG_SEGMENT_LIVE';
      EXECUTE IMMEDIATE S3;
      COMMIT;

      CALL dbadm.sp_runstats_v2 ('DM', 'RPT_HEXDM_AGG_SEGMENT_COMP');
      CALL etl.sp_trace (
              entity           => v_entity,
              step_info        => 'runstats RPT_HEXDM_AGG_SEGMENT_COMP');

      CALL dbadm.sp_runstats_v2 ('DM', 'RPT_HEXDM_AGG_SEGMENT_LIVE');
      CALL etl.sp_trace (
              entity           => v_entity,
              step_info        => 'runstats RPT_HEXDM_AGG_SEGMENT_LIVE');

      CALL etl.sp_trace (entity      => v_entity,
                         step_info   => 'Procedure Completed successfully');
   END
  @
grant execute on procedure ETL.SP_RPT_HEXDM_AGG_SEGMENT_LOAD to role oretlrw
@
  
  
